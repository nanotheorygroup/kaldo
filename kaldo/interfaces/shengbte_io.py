"""
kaldo
Anharmonic Lattice Dynamics
"""
from pathlib import Path

import numpy as np
from ase.units import Rydberg, Bohr
from ase import Atoms
from kaldo.grid import Grid
from sparse import COO
from kaldo.helpers.logger import get_logger
from numpy.typing import ArrayLike
from kaldo.interfaces.common import ForceConstantData, ensure_replicas
logging = get_logger()


def _split_index(index, nx, ny, nz):
    """Split index into ix, iy, iz, iatom. A helper function for read_second_order_matrix.
    index = (((iatom * nz + iz) * ny + iy) * nx + ix), assuming index is zero-indexing. """
    tmp1, ix = divmod(index, nx)
    tmp2, iy = divmod(tmp1, ny)
    iatom, iz = divmod(tmp2, nz)
    return ix, iy, iz, iatom


def read_second_order_matrix(filename, supercell):
    """Read second order force constants from a file in VASP format.

    Parameters
    ----------
    filename : str
        The path to file of second order force constants in VASP format.

    supercell : [t1, t2, t3]
        The size of the supercell as t1 * t2 * t3.

    Returns
    -------
        second_order : np.ndarray(i_at, alpha, t1, t2, t3, j_at, beta)
            The array contains second order force constants.
            alpha and beta are directional indexes in x,y,z.
            t1, t2, t3 is the index to the supercell for j-th atom.
            i_at and j_at are the indexes to the atoms as in unit cell.
    """
    with open(filename, 'r') as file:
        first_row = file.readline()
        n_rows = int(first_row.strip())
        n_replicas = np.prod(supercell)
        n_unit_atoms = int(n_rows / n_replicas)

        second_order = np.zeros((n_unit_atoms, 3, supercell[0],
                                 supercell[1], supercell[2], n_unit_atoms, 3))

        line = file.readline()
        while line:
            try:
                # VASP uses one-indexing
                i, j = np.array([int(x) for x in line.split()])
                # convert to zero-indexing
                i -= 1
                j -= 1
            except ValueError as err:
                print(err)

            # i_ix, i_iy, i_iz, i_iatom, j_ix, j_iy, j_iz, j_iatom, alpha are zero-indexing
            i_ix, i_iy, i_iz, i_iatom = _split_index(i, supercell[0], supercell[1], supercell[2])
            j_ix, j_iy, j_iz, j_iatom = _split_index(j, supercell[0], supercell[1], supercell[2])
            for alpha in range(3):
                if (i_ix == 0) and (i_iy == 0) and (i_iz == 0):
                    line = file.readline()
                    second_order[i_iatom, alpha, j_ix, j_iy, j_iz, j_iatom, :] = \
                        np.array([float(x) for x in line.split()])
                else:
                    file.readline()
            line = file.readline()
    return second_order


def read_second_order_qe_matrix(filename):
    """Read second order force constants from a file generated by q2r.x using DPFT in Quantum Espresso.

    Parameters
    ----------
    filename : str
        The path to file of second order force constants in Quantum Espresso format.

    Returns
    -------
        second : np.ndarray(i_at, alpha, t1, t2, t3, j_at, beta)
            The array contains second order force constants.
            alpha and beta are directional indexes in x,y,z.
            t1, t2, t3 is the index to the supercell for j-th atom.
            i_at and j_at are the indexes to the atoms as in unit cell.

        supercell : [t1, t2, t3]
            The size of the supercell as t1 * t2 * t3.
    """
    with open(filename, 'r') as file:
        # skip all the prelude info, jump to second order force constants

        # read first 3 integers in the first line: ntype, n_atoms, ibrav
        ntype, n_atoms, ibrav = [int(x) for x in file.readline().split()[:3]]

        if (ibrav == 0):
            # skip 3 lines of cell parameters
            for _ in range(3):
                file.readline()
        # skip lines of types of atoms
        for _ in range(ntype):
            file.readline()
        # skip lists of atom positions
        for _ in range(n_atoms):
            file.readline()

        # Read Dielectric constant tensor if it has it
        polar = file.readline()
        if ("T" in polar):
            logging.info('Charge data found in 2nd order QE file')
            charges = np.zeros((n_atoms + 1, 3, 3))
            for alpha in np.arange(3):  # Dielectric constant tensor
                charges[0, alpha, :] = file.readline().split()
            for na in np.arange(n_atoms):  # Born effective charges
                file.readline()
                for alpha in np.arange(3):
                    charges[na + 1, alpha, :] = file.readline().split()
        else:
            charges = None

        # Read second order force constants
        # read t1*t2*t3 supercell
        supercell = [int(x) for x in file.readline().split()]
        # dimension of supercell info should be 3 as t1*t2*t3
        assert len(supercell) == 3

        second = np.zeros((3, 3, n_atoms, n_atoms, supercell[0], supercell[1], supercell[2]))

        # there are 3 * 3 * n_atoms * n_atoms blocks of force constants
        for _i in range(3 * 3 * n_atoms * n_atoms):
            alpha, beta, i_at, j_at = [int(x) - 1 for x in file.readline().split()]

            # each block contains t1*t2*t3 force constants
            for _j in range(supercell[0] * supercell[1] * supercell[2]):
                # line format: "<t1>, <t2>, <t3>, <second order force>"
                line = file.readline().split()
                t1, t2, t3 = [int(x) - 1 for x in line[:3]]
                second[alpha, beta, i_at, j_at, t1, t2, t3] = float(line[3]) * (Rydberg / (Bohr ** 2))
        second = second.transpose(2, 0, 4, 5, 6, 3, 1)
        return second, supercell, charges



def read_third_order_matrix(third_file: str,
                            atoms: Atoms,
                            supercell: tuple[int, int, int],
                            order: str = 'C'):
    """Read third order force constants from a file in VASP format.
    """
    n_unit_atoms = atoms.positions.shape[0]
    n_replicas = np.prod(supercell)
    third_order = np.zeros((n_unit_atoms, 3, n_replicas, n_unit_atoms, 3, n_replicas, n_unit_atoms, 3))
    current_grid = Grid(supercell, order=order)

    with open(third_file, 'r') as file:
        first_line = file.readline()
        n_third = int(first_line.strip())
        for i in range(n_third):
            # skip two lines
            file.readline()
            file.readline()

            # next two lines are the positions of the second and third cell
            second_cell_position = np.array([float(x) for x in file.readline().split()])
            second_cell_id = current_grid.cell_position_to_id(second_cell_position, atoms.cell, is_wrapping=True)

            third_cell_position = np.array([float(x) for x in file.readline().split()])
            third_cell_id = current_grid.cell_position_to_id(third_cell_position, atoms.cell, is_wrapping=True)

            # index to atom
            atom_i, atom_j, atom_k = np.array([int(x) for x in file.readline().split()]) - 1

            # for x,y,z directions with 3 atoms
            for _ in range(27):
                values = np.array([float(x) for x in file.readline().split()])
                alpha, beta, gamma = values[:3].round(0).astype(int) - 1
                third_order[atom_i, alpha, second_cell_id, atom_j, beta, third_cell_id, atom_k, gamma] = values[
                        3]

    third_order = third_order.reshape((n_unit_atoms * 3, n_replicas * n_unit_atoms * 3, n_replicas *
                                       n_unit_atoms * 3))
    return third_order


def read_third_d3q(filename: str,
                   atoms: Atoms,
                   supercell: tuple[int, int, int] | ArrayLike,
                   order: str = 'C') -> np.ndarray[tuple[int, int, int, int, int, int, int, int],
                                                   np.dtype[np.float64]]:
    """Read third order d3q format.

    Parameters
    ----------
    filename : str
        The path to file of third order force constants in d3q format.

    supercell : tuple[int, int, int], shape as [t1, t2, t3]
        The size of the supercell as t1 * t2 * t3.

    Returns
    -------
        third_order : np.ndarray[atom_i, alpha, second_cell_id, atom_j, beta, third_cell_id, atom_k, gamma]
            The array contains third order force constants.
            alpha, beta, and gamma are directional indexes in x,y,z.
            second_cell_id is the index to the supercell for j-th atom.
            third_cell_id is the index to the supercell for k-th atom.
            atom_i, atom_j and atom_k are the indexes to the atoms as in unit cell.
    """
    # Note: d3q is similar to second order qe format.

    with open(filename, 'r') as file:
        n_unit_atoms = atoms.positions.shape[0]
        n_replicas = np.prod(supercell)
        current_grid = Grid(supercell, order=order)
        supercell = np.array(supercell)

        # initalize third order force constant
        third_order = np.zeros((n_unit_atoms, 3, n_replicas, n_unit_atoms, 3, n_replicas, n_unit_atoms, 3))

        # read first line
        ntype, n_atoms, ibrav = [int(x) for x in file.readline().split()[:3]]

        if (ibrav == 0):
            # skip 3 lines of cell parameters
            for _ in np.arange(3):
                file.readline()

        # skip lines of types of atoms
        for _ in np.arange(ntype):
            file.readline()
        # skip lists of atom positions
        for _ in np.arange(n_atoms):
            file.readline()

        # skip Dielectric constant tensor if it has
        polar = file.readline()
        if ("T" in polar):
            for _ in np.arange(3):
                file.readline()
            for _ in np.arange(n_atoms):
                file.readline()
                for _ in np.arange(3):
                    file.readline()

        # next line is 3rd order supercell
        test_supercell = np.array([int(x) for x in file.readline().split()])
        # the third supercell can be different to the second one
        logging.info('Important: FORCECONSTANTS_3RD must be generated by d3q without recentering. Cell indeces must be from 0 to nrep, not [-nrep/2,nrep/2]')
        if not np.array_equal(supercell, test_supercell):
            logging.error(f'third supercell not consistent with 3rd Forces file: {test_supercell} != {supercell}')

        error_notation = 0
        for i in range((3*n_unit_atoms)**3):
            alpha, beta, gamma, atom_i, atom_j, atom_k = np.array([int(x) for x in file.readline().split()]) - 1

            # skip a line
            file.readline()
            for j in range(n_replicas**2):
                readline = file.readline().split()

                second_cell_index = [int(x) for x in readline[:3]]
                third_cell_index = [int(x) for x in readline[3:6]]

                # wrap cell index
                second_cell_index -= supercell*np.rint(second_cell_index/supercell)
                third_cell_index -= supercell*np.rint(third_cell_index/supercell)

                second_cell_id = current_grid.grid_index_to_id(second_cell_index, is_wrapping=True)
                third_cell_id =  current_grid.grid_index_to_id(third_cell_index, is_wrapping=True)

                if readline[6][-4] == 'E':
                    # it has two digits for exp part
                    third_order[atom_i, alpha, second_cell_id,
                                atom_j, beta, third_cell_id,
                                atom_k, gamma] = float(readline[6]) * (Rydberg / (Bohr ** 3))
                else:
                    third_order[atom_i, alpha, second_cell_id, atom_j, beta, third_cell_id, atom_k, gamma] = 0.0
                    error_notation += 1

        logging.info('error with notation number < e-100, used default value=0.0. It happened {} times'.format(error_notation))

        third_order = third_order.reshape((n_unit_atoms * 3,
                                           n_replicas * n_unit_atoms * 3,
                                           n_replicas * n_unit_atoms * 3))
        return third_order


def load_second_vasp(*, folder: Path, resolved, filenames=("FORCE_CONSTANTS_2ND", "FORCE_CONSTANTS"), **_) -> ForceConstantData:
    for name in filenames:
        path = folder / name
        if path.exists():
            raw = read_second_order_matrix(str(path), resolved.supercell)
            break
    else:
        qe_path = folder / "espresso.ifc2"
        if qe_path.exists():
            return load_second_qe(folder=folder, resolved=resolved, filename="espresso.ifc2")
        raise FileNotFoundError(f"No FORCE_CONSTANTS_2ND file found in '{folder}'.")

    n_unit = raw.shape[0]
    n_rep = int(np.prod(resolved.supercell))
    reshaped = raw.reshape((n_unit, 3, n_rep, n_unit, 3))
    value = reshaped[np.newaxis, ...]
    replicas = ensure_replicas(resolved, folder, ("replicated_atoms.xyz", "replicated_atoms_second.xyz"))
    data = ForceConstantData(
        order=2,
        value=value,
        unit_atoms=resolved.unit_atoms,
        supercell=resolved.supercell,
        replicated_atoms=replicas,
        grid_order="F",
    )
    if resolved.charges is not None:
        data.metadata["charges"] = resolved.charges
    data.metadata["apply_acoustic_sum"] = True
    return data


def load_second_qe(*, folder: Path, resolved, filename: str = "espresso.ifc2", **_) -> ForceConstantData:
    raw, supercell, charges = read_second_order_qe_matrix(str(folder / filename))
    n_unit = raw.shape[0]
    n_rep = int(np.prod(supercell))
    reshaped = raw.reshape((n_unit, 3, n_rep, n_unit, 3))
    transposed = reshaped.transpose(3, 4, 2, 0, 1)
    value = transposed[np.newaxis, ...]
    resolved_qe = resolved.with_supercell(tuple(supercell))
    replicas = ensure_replicas(resolved_qe, folder, ("replicated_atoms.xyz", "replicated_atoms_second.xyz", "infile.ssposcar"))
    data = ForceConstantData(
        order=2,
        value=value,
        unit_atoms=resolved.unit_atoms,
        supercell=tuple(supercell),
        replicated_atoms=replicas,
        grid_order="F",
    )
    if charges is not None:
        data.metadata["charges"] = charges
    data.metadata["apply_acoustic_sum"] = True
    return data


def load_third_vasp(*, folder: Path, resolved, filename: str = "FORCE_CONSTANTS_3RD", **_) -> ForceConstantData:
    raw = read_third_order_matrix(str(folder / filename), resolved.unit_atoms, resolved.supercell, order='C')
    replicas = ensure_replicas(resolved, folder, ("replicated_atoms_third.xyz", "replicated_atoms.xyz"))
    return ForceConstantData(
        order=3,
        value=raw,
        unit_atoms=resolved.unit_atoms,
        supercell=resolved.supercell,
        replicated_atoms=replicas,
        grid_order="F",
    )


def load_third_d3q(*, folder: Path, resolved, filename: str = "FORCE_CONSTANTS_3RD", **_) -> ForceConstantData:
    raw = read_third_d3q(str(folder / filename), resolved.unit_atoms, resolved.supercell, order='C')
    n_unit = resolved.unit_atoms.positions.shape[0]
    n_rep = int(np.prod(resolved.supercell))
    value = raw.reshape((3 * n_unit, 3 * n_rep * n_unit, 3 * n_rep * n_unit))
    replicas = ensure_replicas(resolved, folder, ("replicated_atoms_third.xyz", "replicated_atoms.xyz"))
    return ForceConstantData(
        order=3,
        value=value,
        unit_atoms=resolved.unit_atoms,
        supercell=resolved.supercell,
        replicated_atoms=replicas,
        grid_order="F",
        metadata={"layout": "d3q"},
    )


def import_control_file(control_file):
    positions = []
    latt_vecs = []
    eps_vecs = []
    bec_vecs = []
    lfactor = 1
    masses = None
    with open(control_file, "r") as fo:
        lines = fo.readlines()
    for line in lines:
        if 'lattvec' in line:
            value = line.split('=')[1]
            latt_vecs.append(np.array([float(x.rstrip(',')) for x in value.split()]))
        if 'elements' in line and not ('nelements' in line):
            value = line.split('=')[1]
            # TODO: only one species at the moment
            value = value.replace('"', '\'')
            value = value.replace(" ", '')
            value = value.replace("\n", '')
            value = value.replace(',', '')
            value = value.replace("''", '\t')
            value = value.replace("'", '')
            elements = value.split("\t")
        if 'types' in line:
            value = line.split('=')[1]
            types = np.array([int(x.rstrip(',')) for x in value.split()])
        if 'positions' in line:
            value = line.split('=')[1]
            positions.append(np.array([float(x.rstrip(',')) for x in value.split()]))
        if 'lfactor' in line:
            lfactor = float(line.split('=')[1].split(',')[0])
        # TODO: only one species/mass at the moment
        if 'masses' in line:
            value = line.split('=')[1]
            masses=np.array([float(x.rstrip(',')) for x in value.split()])
            #masses = float(line.split('=')[1].split(',')[0])
        if 'scell' in line:
            value = line.split('=')[1]
            supercell = np.array([int(x.rstrip(',')) for x in value.split()])
        if 'epsilon' in line:
            value = line.split('=')[1]
            eps_vecs.append(np.array([float(x.rstrip(',')) for x in value.split()]))
        if 'born' in line:
            value = line.split('=')[1]
            bec_vecs.append(np.array([float(x.rstrip(',')) for x in value.split()]))
    # l factor is in nanometer
    cell = np.array(latt_vecs) * lfactor * 10
    positions = np.array(positions).dot(cell)
    list_of_elem = []
    if masses is None:
        for i in range(len(types)):
            list_of_elem.append(elements[types[i] - 1])

        atoms = Atoms(list_of_elem,
                      positions=positions,
                      cell=cell,
                      pbc=[1, 1, 1])
    else:
        list_of_masses = []
        for i in range(len(types)):
            list_of_elem.append(elements[types[i] - 1])
            list_of_masses.append(masses[types[i] - 1])
        atoms = Atoms(list_of_elem,
                      positions=positions,
                      cell=cell,
                      masses=list_of_masses,
                      pbc=[1, 1, 1])

    logging.info('Atoms object created.')
    if len(eps_vecs) == 0:
        charges = None
    else:
        charges = np.zeros((len(atoms)+1, 3, 3))
        charges[0, ...] = np.array(eps_vecs)
        charges[1:, ...] = np.array(bec_vecs).reshape((len(atoms), 3, 3))
        logging.info('Charge data found in CONTROL file.')
    return atoms, supercell, charges


def save_second_order_matrix(phonons):

    filename = 'FORCE_CONSTANTS_2ND'
    filename = phonons.folder + '/' + filename
    forceconstants = phonons.forceconstants
    second_order = forceconstants.second
    n_atoms_unit_cell = forceconstants.atoms.positions.shape[0]
    n_replicas = phonons.forceconstants.n_replicas
    second_order = second_order.reshape((n_atoms_unit_cell, 3, n_replicas, n_atoms_unit_cell, 3))


    #TODO: this is a bit hacky. ShengBTE wants the whole second order matrix, but actually uses only the reduced one. So we fill the rest with zeros
    with open(filename, 'w+') as file:
        file.write(str(n_atoms_unit_cell * n_replicas) + '\n')
        for i0 in range(n_atoms_unit_cell):
            for l0 in range(n_replicas):
                for i1 in range(n_atoms_unit_cell):
                    for l1 in range(n_replicas):
                        file.write(str(l0 + i0 * n_replicas + 1) + '  ' + str(l1 + i1 * n_replicas + 1) + '\n')
                        if l0 == 0:
                            sub_second = second_order[i0, :, l1, i1, :]
                        else:
                            sub_second = np.zeros((3, 3))

                        file.write('%.6f %.6f %.6f\n' % (sub_second[0][0], sub_second[0][1], sub_second[0][2]))
                        file.write('%.6f %.6f %.6f\n' % (sub_second[1][0], sub_second[1][1], sub_second[1][2]))
                        file.write('%.6f %.6f %.6f\n' % (sub_second[2][0], sub_second[2][1], sub_second[2][2]))


    logging.info('second order sheng saved')


def save_second_order_qe_matrix(phonons):
    shenbte_folder = phonons.folder + '/'
    n_replicas = phonons.forceconstants.n_replicas
    n_atoms = int(phonons.n_modes / 3)
    second_order = phonons.forceconstants.second.value.reshape((n_atoms, 3, n_replicas, n_atoms, 3))
    filename = 'espresso.ifc2'
    filename = shenbte_folder + filename
    file = open ('%s' % filename, 'w+')

    list_of_index = phonons.list_of_index()

    file.write (header(phonons))
    for alpha in range (3):
        for beta in range (3):
            for i in range (n_atoms):
                for j in range (n_atoms):
                    file.write('%4d %4d %4d %4d\n' % (alpha + 1, beta + 1, i + 1, j + 1))
                    for id_replica in range(list_of_index.shape[0]):

                        l_vec = (phonons.list_of_index()[id_replica] + 1)
                        for delta in range(3):
                            if l_vec[delta] <= 0:
                                l_vec[delta] = phonons.forceconstants.supercell[delta]


                        file.write('%4d %4d %4d' % (int(l_vec[2]), int(l_vec[1]), int(l_vec[2])))

                        matrix_element = second_order[i, alpha, id_replica, j, beta]

                        matrix_element = matrix_element / Rydberg * (
                                Bohr ** 2)
                        file.write ('\t %.11E' % matrix_element)
                        file.write ('\n')
    file.close ()
    logging.info('second order qe sheng saved')


def save_third_order_matrix(phonons):
    filename = 'FORCE_CONSTANTS_3RD'
    filename = phonons.folder + '/' + filename
    file = open ('%s' % filename, 'w+')
    n_in_unit_cell = len(phonons.atoms.numbers)
    n_replicas = phonons.forceconstants.n_replicas
    third_order = phonons.forceconstants.third.value\
        .reshape((n_replicas, n_in_unit_cell, 3, n_replicas, n_in_unit_cell, 3, n_replicas, n_in_unit_cell, 3))\
        .todense()

    block_counter = 0
    for i_0 in range (n_in_unit_cell):
        for n_1 in range (n_replicas):
            for i_1 in range (n_in_unit_cell):
                for n_2 in range (n_replicas):
                    for i_2 in range (n_in_unit_cell):
                        three_particles_interaction = third_order[0, i_0, :, n_1, i_1, :, n_2, i_2, :]
                        three_particles_interaction = three_particles_interaction

                        if (np.abs (three_particles_interaction) > 1e-9).any ():
                            block_counter += 1
                            file.write ('\n  ' + str (block_counter))
                            rep_position = phonons.forceconstants.second.list_of_replicas[n_1]
                            file.write ('\n  ' + str (rep_position[0]) + ' ' + str (rep_position[1]) + ' ' + str (
                                rep_position[2]))
                            rep_position = phonons.forceconstants.second.list_of_replicas[n_2]
                            file.write ('\n  ' + str (rep_position[0]) + ' ' + str (rep_position[1]) + ' ' + str (
                                rep_position[2]))
                            file.write ('\n  ' + str (i_0 + 1) + ' ' + str (i_1 + 1) + ' ' + str (i_2 + 1))

                            for alpha_0 in range (3):
                                for alpha_1 in range (3):
                                    for alpha_2 in range (3):
                                        file.write (
                                            '\n  ' + str (alpha_0 + 1) + ' ' + str (alpha_1 + 1) + ' ' + str (
                                                alpha_2 + 1) + "  %.11E" % three_particles_interaction[
                                                alpha_0, alpha_1, alpha_2])
                            file.write ('\n')
    file.close ()
    with open (filename, 'r') as original:
        data = original.read ()
    with open (filename, 'w+') as modified:
        modified.write ('  ' + str (block_counter) + '\n' + data)
    logging.info('third order sheng saved')


def create_control_file_string(phonons, is_espresso=False):
    k_points = phonons.kpts
    elements = phonons.atoms.get_chemical_symbols ()
    unique_elements = np.unique (phonons.atoms.get_chemical_symbols ())
    string = ''
    string += '&allocations\n'
    string += '\tnelements=' + str(len(unique_elements)) + '\n'
    string += '\tnatoms=' + str(len(elements)) + '\n'
    string += '\tngrid(:)=' + str (k_points[0]) + ' ' + str (k_points[1]) + ' ' + str (k_points[2]) + '\n'
    string += '&end\n'
    string += '&crystal\n'
    string += '\tlfactor=0.1,\n'
    for i in range (phonons.atoms.cell.shape[0]):
        vector = phonons.atoms.cell[i]
        string += '\tlattvec(:,' + str (i + 1) + ')= ' + str (vector[0]) + ' ' + str (vector[1]) + ' ' + str (
            vector[2]) + '\n'
    string += '\telements= '
    for element in np.unique(phonons.atoms.get_chemical_symbols()):
        string += '\"' + element + '\",'
    string +='\n'
    string += '\ttypes='
    for element in phonons.atoms.get_chemical_symbols():
        string += str(type_element_id(phonons.atoms, element) + 1) + ' '
    string += ',\n'
    for i in range (phonons.atoms.positions.shape[0]):
        # TODO: double check this for more complicated geometries
        cellinv = np.linalg.inv (phonons.atoms.cell)
        vector = cellinv.dot(phonons.atoms.positions[i])
        string += '\tpositions(:,' + str (i + 1) + ')= ' + str (vector[0]) + ' ' + str (vector[1]) + ' ' + str (
            vector[2]) + '\n'
    string += '\tscell(:)=' + str (phonons.supercell[0]) + ' ' + str (phonons.supercell[1]) + ' ' + str (
        phonons.supercell[2]) + '\n'
    string += '&end\n'
    string += '&parameters\n'
    string += '\tT=' + str (phonons.temperature) + '\n'
    string += '\tscalebroad=1.0\n'
    string += '&end\n'
    string += '&flags\n'
    if is_espresso:
        string += '\tespresso=.true.\n'
    else:
        string += '\tespresso=.false.\n'
    if phonons.is_classic:
        string += '\tclassical=.true.\n'
    string += '\tnonanalytic=.false.\n'
    string += '\tisotopes=.false.\n'
    string += '&end\n'
    return string


def create_control_file(phonons):
    folder = phonons.folder
    filename = folder + '/CONTROL'
    string = create_control_file_string (phonons)

    with open (filename, 'w+') as file:
        file.write (string)


def header(phonons):

    # this convert masses to qm masses

    nat = len (phonons.atoms.get_chemical_symbols ())

    # TODO: The dielectric calculation is not implemented yet
    dielectric_constant = 1.
    born_eff_charge = 0.000000

    ntype = len (np.unique (phonons.atoms.get_chemical_symbols ()))
    # in quantum espresso ibrav = 0, do not use symmetry and use cartesian vectors to specify symmetries
    ibrav = 0
    header_str = ''
    header_str += str (ntype) + ' '
    header_str += str (nat) + ' '
    header_str += str (ibrav) + ' '

    # TODO: I'd like to have ibrav = 1 and put the actual positions here
    header_str += '0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 \n'
    header_str += matrix_to_string (phonons.atoms.cell)
    mass_factor = 1.8218779 * 6.022e-4

    for i in range (ntype):
        mass = np.unique (phonons.forceconstants.atoms.get_masses ())[i] / mass_factor
        label = np.unique (phonons.forceconstants.atoms.get_chemical_symbols ())[i]
        header_str += str (i + 1) + ' \'' + label + '\' ' + str (mass) + '\n'

    # TODO: this needs to be changed, it works only if all the atoms in the unit cell are different species
    for i in range (nat):
        header_str += str (i + 1) + '  ' + str (i + 1) + '  ' + matrix_to_string (phonons.atoms.positions[i])
    header_str += 'T \n'
    header_str += matrix_to_string (np.diag (np.ones (3)) * dielectric_constant)
    for i in range (nat):
        header_str += str (i + 1) + '\n'
        header_str += matrix_to_string (np.diag (np.ones (3)) * born_eff_charge * (-1) ** i)
    header_str += str (phonons.supercell[0]) + '    '
    header_str += str (phonons.supercell[1]) + '    '
    header_str += str (phonons.supercell[2]) + '\n'
    return header_str




def matrix_to_string(matrix):
    string = ''
    if len (matrix.shape) == 1:
        for i in range (matrix.shape[0]):
            string += '%.7f' % matrix[i] + ' '
        string += '\n'
    else:
        for i in range (matrix.shape[0]):
            for j in range (matrix.shape[1]):
                string += '%.7f' % matrix[i, j] + ' '
            string += '\n'
    return string


def type_element_id(atoms, element_name):
    # TODO: remove this method
    unique_elements = np.unique (atoms.get_chemical_symbols ())
    for i in range(len(unique_elements)):
        element = unique_elements[i]
        if element == element_name:
            return i
